name: Build and Deploy CryptoLink to AKS

on:
  push:
    branches: [ master ]
  workflow_dispatch:

env:
  # Stała nazwa ACR - bez dynamicznych numerów
  ACR_NAME: 'cryptolinkregistry' 
  AKS_CLUSTER_NAME: 'aks-cryptolink'

jobs:
  # === JOB 1: WDRÓŻ INFRASTRUKTURĘ ===
  provision-infra:
    name: 'Provision Infrastructure'
    runs-on: ubuntu-latest

    outputs:
      ACR_LOGIN_SERVER: ${{ steps.deploy-bicep.outputs.acrLoginServer }}

    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Deploy Bicep Infrastructure'
      id: deploy-bicep
      uses: azure/arm-deploy@v1
      with:
        scope: resourcegroup
        subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        resourceGroupName: ${{ secrets.RESOURCE_GROUP }}
        template: ./infra/main.bicep
        # Przywrócono sshPublicKey
        parameters: >
          sshPublicKey="${{ secrets.SSH_PUBLIC_KEY }}"
          postgresAdminPassword="${{ secrets.POSTGRES_ADMIN_PASSWORD }}"
          aksClusterName="${{ env.AKS_CLUSTER_NAME }}"
          acrName="${{ env.ACR_NAME }}"
        failOnStdErr: false

  # ==== JOB 2: ZBUDUJ I OPUBLIKUJ DOCKER ====
  build-and-push-docker:
    name: 'Build and Push Docker Image'
    runs-on: ubuntu-latest
    needs: provision-infra

    outputs:
      IMAGE_NAME: ${{ steps.build-image.outputs.IMAGE_NAME }}
      
    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # Poprawione logowanie do ACR
    - name: 'Login to Azure Container Registry'
      run: az acr login --name ${{ env.ACR_NAME }}
    
    - name: 'Build and Push Docker Image'
      id: build-image
      run: |
        LOGIN_SERVER=${{ needs.provision-infra.outputs.ACR_LOGIN_SERVER }}
        IMAGE_TAG=${{ github.sha }}
        FULL_IMAGE_NAME="$LOGIN_SERVER/cryptolink-webui:$IMAGE_TAG"
        
        # Budowanie
        docker build . -f CryptoLink.WebUI/CryptoLink.WebUI/Dockerfile -t $FULL_IMAGE_NAME
        
        # Wypychanie
        docker push $FULL_IMAGE_NAME

        echo "IMAGE_NAME=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT

# === JOB 3: WDRÓŻ NA AKS ===
  deploy-to-aks:
    name: 'Deploy Application to AKS'
    runs-on: ubuntu-latest
    needs: [provision-infra, build-and-push-docker]

    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Set AKS context'
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ secrets.RESOURCE_GROUP }}
        cluster-name: ${{ env.AKS_CLUSTER_NAME }}
    
    - name: 'Substitute Image Name in Manifests'
      uses: cschleiden/replace-tokens@v1
      with:
        files: 'kubernetes/*.yaml'
        tokenPrefix: '${'
        tokenSuffix: '}'
      env:
        IMAGE_NAME: ${{ needs.build-and-push-docker.outputs.IMAGE_NAME }}

    # === TU JEST KLUCZOWA ZMIANA ===
    - name: Generate All Secrets
      env:
        # Przekazujemy hasło jako zmienną środowiskową do powłoki
        DB_PASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
      run: |
        # Tworzymy namespace
        kubectl create namespace cryptolink-app --dry-run=client -o yaml | kubectl apply -f -

        # 1. SEKRET DLA BAZY DANYCH (POSTGRES)
        # Używamy zmiennej $DB_PASSWORD
        kubectl create secret generic postgres-secret \
          --namespace cryptolink-app \
          --from-literal=POSTGRES_USER="postgres" \
          --from-literal=POSTGRES_PASSWORD="$DB_PASSWORD" \
          --dry-run=client -o yaml | kubectl apply -f -

        # 2. SEKRET DLA APLIKACJI (CONNECTION STRING)
        # Budujemy string w zmiennej, żeby uniknąć problemów z Ballem i średnikami
        CONN_STRING="Host=postgres-db-service;Port=5432;Database=cryptolink;Username=postgres;Password=$DB_PASSWORD"
        
        kubectl create secret generic cryptolink-app-secrets \
          --namespace cryptolink-app \
          --from-literal=ConnectionStrings__Default="$CONN_STRING" \
          --dry-run=client -o yaml | kubectl apply -f -

        # 3. SEKRETY JWT
        kubectl create secret generic cryptolink-auth-secrets \
          --namespace cryptolink-app \
          --from-literal=JwtOptions__SecretKey="${{ secrets.JWT_SECRET_KEY }}" \
          --from-literal=Jwt__SecretKey="${{ secrets.JWT_SECRET_KEY }}" \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: 'Deploy to AKS'
      uses: Azure/k8s-deploy@v4
      with:
        action: 'deploy'
        namespace: 'cryptolink-app'
        manifests: |
          kubernetes/00-namespace.yaml
          kubernetes/07-service-account.yaml
          kubernetes/03-postgres-statefulset.yaml
          kubernetes/04-postgres-service.yaml
          kubernetes/05-app-deployment.yaml
          kubernetes/06-app-service.yaml
          kubernetes/08-network-policy.yaml
