name: Build and Deploy CryptoLink to AKS

on:
  push:
    branches: [ master, cicd_kubernetes ]
  workflow_dispatch:

env:
  # Upewnij się, że ta nazwa zgadza się z tą w Bicep (jeśli jest na sztywno)
  ACR_NAME: 'cryptolinkBRCh169606169600' 
  AKS_CLUSTER_NAME: 'aks-cryptolink'

jobs:
  # === JOB 1: WDRÓŻ INFRASTRUKTURĘ ===
  provision-infra:
    name: 'Provision Infrastructure'
    runs-on: ubuntu-latest

    outputs:
      ACR_LOGIN_SERVER: ${{ steps.deploy-bicep.outputs.acrLoginServer }}

    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Deploy Bicep Infrastructure'
      id: deploy-bicep
      uses: azure/arm-deploy@v1
      with:
        scope: resourcegroup
        subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        resourceGroupName: ${{ secrets.RESOURCE_GROUP }}
        template: ./infra/main.bicep
        # Przywrócono sshPublicKey
        parameters: >
          sshPublicKey="${{ secrets.SSH_PUBLIC_KEY }}"
          postgresAdminPassword="${{ secrets.POSTGRES_ADMIN_PASSWORD }}"
          aksClusterName="${{ env.AKS_CLUSTER_NAME }}"
          acrName="${{ env.ACR_NAME }}"
        failOnStdErr: false

  # === JOB 2: ZBUDUJ I OPUBLIKUJ DOCKER ===
  build-and-push-docker:
    name: 'Build and Push Docker Image'
    runs-on: ubuntu-latest
    needs: provision-infra

    outputs:
      IMAGE_NAME: ${{ steps.build-image.outputs.IMAGE_NAME }}
      
    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # Poprawione logowanie do ACR
    - name: 'Login to Azure Container Registry'
      run: az acr login --name ${{ env.ACR_NAME }}
    
    - name: 'Build and Push Docker Image'
      id: build-image
      run: |
        LOGIN_SERVER=${{ needs.provision-infra.outputs.ACR_LOGIN_SERVER }}
        IMAGE_TAG=${{ github.sha }}
        FULL_IMAGE_NAME="$LOGIN_SERVER/cryptolink-webui:$IMAGE_TAG"
        
        # Budowanie
        docker build . -f CryptoLink.WebUI/CryptoLink.WebUI/Dockerfile -t $FULL_IMAGE_NAME
        
        # Wypychanie
        docker push $FULL_IMAGE_NAME

        echo "IMAGE_NAME=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT

  # === JOB 3: WDRÓŻ NA AKS ===
  deploy-to-aks:
    name: 'Deploy Application to AKS'
    runs-on: ubuntu-latest
    needs: [provision-infra, build-and-push-docker]

    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Install kubelogin'
      uses: azure/use-kubelogin@v1
      with:
        kubelogin-version: 'latest'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: 'Set AKS context'
      uses: azure/aks-set-context@v3
      with:
        cluster-name: ${{ env.AKS_CLUSTER_NAME }}
        resource-group: ${{ secrets.RESOURCE_GROUP }}
        admin: 'true'
        use-kubelogin: 'true'

    - name: 'Ensure namespace exists'
      run: kubectl apply -f kubernetes/00-namespace.yaml

    - name: 'Create/Update JWT secret in AKS'
      run: |
        kubectl create secret generic cryptolink-auth-secrets \
          -n cryptolink-app \
          --from-literal=JwtOptions__SecretKey='${{ secrets.JWT_SECRET_KEY }}' \
          --from-literal=Jwt__SecretKey='${{ secrets.JWT_SECRET_KEY }}' \
          --dry-run=client -o yaml | kubectl apply -f -

    # KROK 1: Podmień zmienne w plikach YAML (np. nazwę obrazu)
    # To jest kluczowe, żeby Kubernetes wiedział, jaki konkretnie obraz (SHA) pobrać
    - name: 'Substitute Image Name in Manifests'
      uses: cschleiden/replace-tokens@v1
      with:
        files: 'kubernetes/*.yaml'
        tokenPrefix: '${'
        tokenSuffix: '}'
      env:
        IMAGE_NAME: ${{ needs.build-and-push-docker.outputs.IMAGE_NAME }}

    - name: Create App Connection Secret
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.KUBE_CONFIG }}
      
    - name: Generate Missing Secrets
      run: |
        # Tworzymy namespace jeśli nie istnieje (dla pewności)
        kubectl create namespace cryptolink-app --dry-run=client -o yaml | kubectl apply -f -

        # 1. Tworzymy brakujący sekret do bazy danych (ConnectionString)
        # Używamy dry-run i apply, żeby działało idempotentnie (zawsze)
        kubectl create secret generic cryptolink-app-secrets \
          --namespace cryptolink-app \
          --from-literal=ConnectionStrings__Default="Host=postgres-db-service;Port=5432;Database=cryptolink;Username=azureuser;Password=${{ secrets.POSTGRES_ADMIN_PASSWORD }}" \
          --dry-run=client -o yaml | kubectl apply -f -

        # 2. Tworzymy sekrety do JWT (jeśli ich też brakuje w repo)
        kubectl create secret generic cryptolink-auth-secrets \
          --namespace cryptolink-app \
          --from-literal=JwtOptions__SecretKey="${{ secrets.JWT_SECRET_KEY }}" \
          --from-literal=Jwt__SecretKey="${{ secrets.JWT_SECRET_KEY }}" \
          --dry-run=client -o yaml | kubectl apply -f -

    # KROK 2: Wdróż manifesty w odpowiedniej kolejności
    - name: 'Deploy to AKS'
      uses: Azure/k8s-deploy@v4
      with:
        action: 'deploy'
        namespace: 'cryptolink-app' # Matches the namespace defined in 00-namespace.yaml
        manifests: |
          kubernetes/00-namespace.yaml
          kubernetes/01-postgres-pvc.yaml
          kubernetes/02-postgres-secret.yaml
          kubernetes/03-postgres-statefulset.yaml
          kubernetes/04-postgres-service.yaml
          kubernetes/05-app-deployment.yaml
          kubernetes/06-app-service.yaml
          kubernetes/08-network-policy.yaml

    - name: Create/Update app connection string secret (from postgres-secret)
      run: |
        DB_USER=$(kubectl get secret -n cryptolink-app postgres-secret -o jsonpath='{.data.POSTGRES_USER}' | base64 -d)
        DB_PASS=$(kubectl get secret -n cryptolink-app postgres-secret -o jsonpath='{.data.POSTGRES_PASSWORD}' | base64 -d)

        kubectl create secret generic cryptolink-app-secrets \
          -n cryptolink-app \
          --from-literal=ConnectionStrings__Default="Host=postgres-db-service;Port=5432;Database=cryptolink;Username=${DB_USER};Password=${DB_PASS}" \
          --dry-run=client -o yaml | kubectl apply -f -
