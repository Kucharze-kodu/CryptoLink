name: Build and Deploy CryptoLink to AKS

on:
  push:
    branches: [ master, cicd_kubernetes ]
  workflow_dispatch:

env:
  # Upewnij się, że ta nazwa zgadza się z tą w Bicep (jeśli jest na sztywno)
  ACR_NAME: 'cryptolinkBRCh169606169600' 
  AKS_CLUSTER_NAME: 'aks-cryptolink'

jobs:
  # === JOB 1: WDRÓŻ INFRASTRUKTURĘ ===
  provision-infra:
    name: 'Provision Infrastructure'
    runs-on: ubuntu-latest

    outputs:
      ACR_LOGIN_SERVER: ${{ steps.deploy-bicep.outputs.acrLoginServer }}

    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Deploy Bicep Infrastructure'
      id: deploy-bicep
      uses: azure/arm-deploy@v1
      with:
        scope: resourcegroup
        subscriptionId: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        resourceGroupName: ${{ secrets.RESOURCE_GROUP }}
        template: ./infra/main.bicep
        # Przywrócono sshPublicKey
        parameters: >
          sshPublicKey="${{ secrets.SSH_PUBLIC_KEY }}"
          postgresAdminPassword="${{ secrets.POSTGRES_ADMIN_PASSWORD }}"
          aksClusterName="${{ env.AKS_CLUSTER_NAME }}"
          acrName="${{ env.ACR_NAME }}"
        failOnStdErr: false

  # === JOB 2: ZBUDUJ I OPUBLIKUJ DOCKER ===
  build-and-push-docker:
    name: 'Build and Push Docker Image'
    runs-on: ubuntu-latest
    needs: provision-infra

    outputs:
      IMAGE_NAME: ${{ steps.build-image.outputs.IMAGE_NAME }}
      
    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # Poprawione logowanie do ACR
    - name: 'Login to Azure Container Registry'
      run: az acr login --name ${{ env.ACR_NAME }}
    
    - name: 'Build and Push Docker Image'
      id: build-image
      run: |
        LOGIN_SERVER=${{ needs.provision-infra.outputs.ACR_LOGIN_SERVER }}
        IMAGE_TAG=${{ github.sha }}
        FULL_IMAGE_NAME="$LOGIN_SERVER/cryptolink-webui:$IMAGE_TAG"
        
        # Budowanie
        docker build . -f CryptoLink.WebUI/CryptoLink.WebUI/Dockerfile -t $FULL_IMAGE_NAME
        
        # Wypychanie
        docker push $FULL_IMAGE_NAME

        echo "IMAGE_NAME=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT

# === JOB 3: WDRÓŻ NA AKS ===
  deploy-to-aks:
    name: 'Deploy Application to AKS'
    runs-on: ubuntu-latest
    needs: [provision-infra, build-and-push-docker]

    steps:
    - name: 'Checkout Repository'
      uses: actions/checkout@v3

    # 1. Logowanie do Azure (Konieczne do pobrania credsów do AKS)
    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # 2. Ustawienie kontekstu AKS (To jest jedyna potrzebna akcja do połączenia)
    - name: 'Set AKS context'
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ secrets.RESOURCE_GROUP }} # lub wpisz 'projekt-BRCh-v2' jeśli sekret nie działa
        cluster-name: ${{ env.AKS_CLUSTER_NAME }}
    
    # 3. Podmiana nazwy obrazu w plikach YAML (np. SHA commita)
    - name: 'Substitute Image Name in Manifests'
      uses: cschleiden/replace-tokens@v1
      with:
        files: 'kubernetes/*.yaml'
        tokenPrefix: '${'
        tokenSuffix: '}'
      env:
        IMAGE_NAME: ${{ needs.build-and-push-docker.outputs.IMAGE_NAME }}

    # 4. Generowanie sekretów (To naprawia błąd "CreateContainerConfigError")
    - name: Generate Missing Secrets
      run: |
        # Tworzymy namespace (jeśli nie istnieje)
        kubectl create namespace cryptolink-app --dry-run=client -o yaml | kubectl apply -f -

        # Tworzymy ConnectionString (używając hasła z GitHub Secrets)
        # UWAGA: Username 'azureuser' to domyślna wartość z Twojego Bicepa. 
        # Jeśli zmieniłeś usera w bazie na 'postgres', zmień to też tutaj!
        kubectl create secret generic cryptolink-app-secrets \
          --namespace cryptolink-app \
          --from-literal=ConnectionStrings__Default="Host=postgres-db-service;Port=5432;Database=postgres;Username=azureuser;Password=${{ secrets.POSTGRES_ADMIN_PASSWORD }}" \
          --dry-run=client -o yaml | kubectl apply -f -

        # Tworzymy sekrety JWT
        kubectl create secret generic cryptolink-auth-secrets \
          --namespace cryptolink-app \
          --from-literal=JwtOptions__SecretKey="${{ secrets.JWT_SECRET_KEY }}" \
          --from-literal=Jwt__SecretKey="${{ secrets.JWT_SECRET_KEY }}" \
          --dry-run=client -o yaml | kubectl apply -f -

    # 5. Wdrożenie manifestów
    - name: 'Deploy to AKS'
      uses: Azure/k8s-deploy@v4
      with:
        action: 'deploy'
        namespace: 'cryptolink-app'
        manifests: |
          kubernetes/00-namespace.yaml
          kubernetes/01-postgres-pvc.yaml
          kubernetes/02-postgres-secret.yaml
          kubernetes/03-postgres-statefulset.yaml
          kubernetes/04-postgres-service.yaml
          kubernetes/05-app-deployment.yaml
          kubernetes/06-app-service.yaml
          kubernetes/08-network-policy.yaml